<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>146.LRU缓存</title>
    <link href="/2024/06/22/146-LRU%E7%BC%93%E5%AD%98/"/>
    <url>/2024/06/22/146-LRU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146.LRU缓存"></a>146.LRU缓存</h2><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2938.区分黑球和白球</title>
    <link href="/2024/06/06/2938-%E5%8C%BA%E5%88%86%E9%BB%91%E7%90%83%E5%92%8C%E7%99%BD%E7%90%83/"/>
    <url>/2024/06/06/2938-%E5%8C%BA%E5%88%86%E9%BB%91%E7%90%83%E5%92%8C%E7%99%BD%E7%90%83/</url>
    
    <content type="html"><![CDATA[<h2 id="2938-区分黑球和白球"><a href="#2938-区分黑球和白球" class="headerlink" title="2938.区分黑球和白球"></a>2938.区分黑球和白球</h2><p>桌子上有 <code>n</code> 个球，每个球的颜色不是黑色，就是白色。</p><p>给你一个长度为 <code>n</code> 、下标从 <strong>0</strong> 开始的二进制字符串 <code>s</code>，其中 <code>1</code> 和 <code>0</code> 分别代表黑色和白色的球。</p><p>在每一步中，你可以选择两个相邻的球并交换它们。</p><p>返回「将所有黑色球都移到右侧，所有白色球都移到左侧所需的 <strong>最小步数</strong>」。</p><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;101&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：我们可以按以下方式将所有黑色球移到右侧：<br>- 交换 s[<span class="hljs-number">0</span>] 和 s[<span class="hljs-number">1</span>]，s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;011&quot;</span>。<br>最开始，<span class="hljs-number">1</span> 没有都在右侧，需要至少 <span class="hljs-number">1</span> 步将其移到右侧。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;100&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：我们可以按以下方式将所有黑色球移到右侧：<br>- 交换 s[<span class="hljs-number">0</span>] 和 s[<span class="hljs-number">1</span>]，s = <span class="hljs-string">&quot;010&quot;</span>。<br>- 交换 s[<span class="hljs-number">1</span>] 和 s[<span class="hljs-number">2</span>]，s = <span class="hljs-string">&quot;001&quot;</span>。<br>可以证明所需的最小步数为 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0111&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：所有黑色球都已经在右侧。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n == s.length &lt;= 105</code></li><li><code>s[i]</code> 不是 <code>&#39;0&#39;</code>，就是 <code>&#39;1&#39;</code>。</li></ul><blockquote><p>思路：累加每个0左边1的个数</p></blockquote><p><strong>示例：101110</strong></p><p>题目要求最后的结果应该是左边全是0，右边全是1.</p><p>所以最后的结果应该是：<strong>001111</strong>.</p><p>tips：在Java中如何遍历字符串？首先遍历肯定要先将字符串转成数组，使用toCharArray()方法可以将String类型字符串转换为char类型数组，再通过for循环&#x2F;for-each循环遍历即可。</p><p>思考：当我们从头开始遍历字符串时，由于时要求最后的结果左边全是0，右边全是1，故当我们遇到0时，下意识的认为不需要做任何操作，因为0本来就应该在左边，这是错误的。当我们遇到0时，需要考虑左边有多少个1，有多少个1就需要交换几次。<em><strong>每次遇到1时，将其计数，每次遇到0时，若0左侧有1，则此时1一定是呈连续状分布在0的左侧，所以我们才说有多少个1就交换几次，对后续遍历也同理，即遇到1的时候增加1的计数器，遇到0的时候根据此时1的数量来增加相应的交换次数，最后返回交换次数即可。</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">minimumSteps</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//注意int可能会导致溢出</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : s.toCharArray())&#123;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                cnt++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                ans += cnt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>WARNING</p><p>使用时 <code>&lt;div class=&quot;note note-primary&quot;&gt;             &lt;p&gt;&lt;code&gt;和&lt;/code&gt;&lt;/p&gt;           &lt;/div&gt;</code> 需单独一行，否则会出现问题</p>          </div><p>这个标签可以嵌入在正文里<span class="label label-danger">警告</span>就像这样。</p>    <div class="fold">      <div class="fold-title fold-into collapsed" data-toggle="collapse" href="#collapse-e6d2f0a0" role="button" aria-expanded="false" aria-controls="collapse-e6d2f0a0">        <div class="fold-arrow">▶</div>this is fold test      </div>      <div class="fold-collapse collapse" id="collapse-e6d2f0a0">        <div class="fold-content">          <p>fold</p><p>fold</p><p>fold</p><p>fold</p><p>fold</p><p>fold</p>        </div>      </div>    </div><div>            <input type="checkbox"  >普通示例          </div><div>            <input type="checkbox"  checked="checked">默认选中          </div>            <input type="checkbox"  >内联示例           后面文字不换行<input type="checkbox" disabled > 也可以只传入一个参数，文字写在后边（这样不支持外联）<br><a class="btn" href="https://www.baidu.com"  title="what" target="_blank">button</a><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/%5Cimg%5Cavatar.png"></div><div class="group-image-wrap"><img src="/%5Cimg%5Cavatar.png"></div><div class="group-image-wrap"><img src="/%5Cimg%5Cavatar.png"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/%5Cimg%5Cavatar.png"></div><div class="group-image-wrap"><img src="/%5Cimg%5Cavatar.png"></div></div></div>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
